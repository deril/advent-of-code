(in-package :aoc-2024-21)

(aoc:define-day 154208 188000493837892) ;; FIXME Remove the hardcoded paths and figure out how to set proper priorities on turns
;; least turns (this becomes important when escaping the missing cell in both numeric and directional pads).
;; moving < over ^ over v over >.

;; Input

(defparameter *codes* (aoc:input))

(defparameter *example-codes*
  '("029A"
    "980A"
    "179A"
    "456A"
    "379A"))

;; Part 1

;; Numeric keypad
;; 7 8 9
;; 4 5 6
;; 1 2 3
;;   0 A

;; Directional keypad
;;   ^ A
;; < v >

;; (defparameter *numpad* '((1 ((2 . >) (4 . ^)))
;;                          (2 ((3 . >) (5 . ^) (1 . <) (0 . v)))
;;                          (3 ((6 . ^) (2 . <) (a . v)))
;;                          (4 ((1 . v) (5 . >) (7 . ^)))
;;                          (5 ((2 . v) (6 . >) (4 . <) (8 . ^)))
;;                          (6 ((3 . v) (5 . <) (9 . ^)))
;;                          (7 ((4 . v) (8 . >)))
;;                          (8 ((5 . v) (9 . >) (7 . <)))
;;                          (9 ((6 . v) (8 . <)))
;;                          (0 ((2 . ^) (a . >)))
;;                          (a ((0 . <) (3 . ^)))))

;; (defparameter *dirpad* '((^ ((a . >) (v . v)))
;;                          (a ((^ . <) (> . v)))
;;                          (< ((v . >)))
;;                          (v ((< . <) (^ . ^) (> . >)))
;;                          (> ((a . ^) (v . <)))))

(defparameter *shortest-path*
  (fset:map
   ('(a 0) '(< a))
   ('(0 a) '(> a))
   ('(a 1) '(^ < < a))
   ('(1 a) '(> > v a))
   ('(a 2) '(< ^ a))
   ('(2 a) '(v > a))
   ('(a 3) '(^ a))
   ('(3 a) '(v a))
   ('(a 4) '(^ ^ < < a))
   ('(4 a) '(> > v v a))
   ('(a 5) '(< ^ ^ a))
   ('(5 a) '(v v > a))
   ('(a 6) '(^ ^ a))
   ('(6 a) '(v v a))
   ('(a 7) '(^ ^ ^ < < a))
   ('(7 a) '(> > v v v a))
   ('(a 8) '(< ^ ^ ^ a))
   ('(8 a) '(v v v > a))
   ('(a 9) '(^ ^ ^ a))
   ('(9 a) '(v v v a))
   ('(0 1) '(^ < a))
   ('(1 0) '(> v a))
   ('(0 2) '(^ a))
   ('(2 0) '(v a))
   ('(0 3) '(^ > a))
   ('(3 0) '(< v a))
   ('(0 4) '(^ < ^ a))
   ('(4 0) '(> v v a))
   ('(0 5) '(^ ^ a))
   ('(5 0) '(v v a))
   ('(0 6) '(^ ^ > a))
   ('(6 0) '(< v v a))
   ('(0 7) '(^ ^ ^ < a))
   ('(7 0) '(> v v v a))
   ('(0 8) '(^ ^ ^ a))
   ('(8 0) '(v v v a))
   ('(0 9) '(^ ^ ^ > a))
   ('(9 0) '(< v v v a))
   ('(1 2) '(> a))
   ('(2 1) '(< a))
   ('(1 3) '(> > a))
   ('(3 1) '(< < a))
   ('(1 4) '(^ a))
   ('(4 1) '(v a))
   ('(1 5) '(^ > a))
   ('(5 1) '(< v a))
   ('(1 6) '(^ > > a))
   ('(6 1) '(< < v a))
   ('(1 7) '(^ ^ a))
   ('(7 1) '(v v a))
   ('(1 8) '(^ ^ > a))
   ('(8 1) '(< v v a))
   ('(1 9) '(^ ^ > > a))
   ('(9 1) '(< < v v a))
   ('(2 3) '(> a))
   ('(3 2) '(< a))
   ('(2 4) '(< ^ a))
   ('(4 2) '(v > a))
   ('(2 5) '(^ a))
   ('(5 2) '(v a))
   ('(2 6) '(^ > a))
   ('(6 2) '(< v a))
   ('(2 7) '(< ^ ^ a))
   ('(7 2) '(v v > a))
   ('(2 8) '(^ ^ a))
   ('(8 2) '(v v a))
   ('(2 9) '(^ ^ > a))
   ('(9 2) '(< v v a))
   ('(3 4) '(< < ^ a))
   ('(4 3) '(v > > a))
   ('(3 5) '(< ^ a))
   ('(5 3) '(v > a))
   ('(3 6) '(^ a))
   ('(6 3) '(v a))
   ('(3 7) '(< < ^ ^ a))
   ('(7 3) '(v v > > a))
   ('(3 8) '(< ^ ^ a))
   ('(8 3) '(v v > a))
   ('(3 9) '(^ ^ a))
   ('(9 3) '(v v a))
   ('(4 5) '(> a))
   ('(5 4) '(< a))
   ('(4 6) '(> > a))
   ('(6 4) '(< < a))
   ('(4 7) '(^ a))
   ('(7 4) '(v a))
   ('(4 8) '(^ > a))
   ('(8 4) '(< v a))
   ('(4 9) '(^ > > a))
   ('(9 4) '(< < v a))
   ('(5 6) '(> a))
   ('(6 5) '(< a))
   ('(5 7) '(< ^ a))
   ('(7 5) '(v > a))
   ('(5 8) '(^ a))
   ('(8 5) '(v a))
   ('(5 9) '(^ > a))
   ('(9 5) '(< v a))
   ('(6 7) '(< < ^ a))
   ('(7 6) '(v > > a))
   ('(6 8) '(< ^ a))
   ('(8 6) '(v > a))
   ('(6 9) '(^ a))
   ('(9 6) '(v a))
   ('(7 8) '(> a))
   ('(8 7) '(< a))
   ('(7 9) '(> > a))
   ('(9 7) '(< < a))
   ('(8 9) '(> a))
   ('(9 8) '(< a))
   ('(< ^) '(> ^ a))
   ('(^ <) '(v < a))
   ('(< v) '(> a))
   ('(v <) '(< a))
   ('(< >) '(> > a))
   ('(> <) '(< < a))
   ('(< A) '(> > ^ a))
   ('(A <) '(v < < a))
   ('(^ v) '(v a))
   ('(v ^) '(^ a))
   ('(^ >) '(v > a))
   ('(> ^) '(< ^ a))
   ('(^ A) '(> a))
   ('(A ^) '(< a))
   ('(v >) '(> a))
   ('(> v) '(< a))
   ('(v A) '(^ > a))
   ('(A v) '(< v a))
   ('(> A) '(^ a))
   ('(A >) '(v a))))

;; (defun shortest-path (start end pad)
;;   (let ((shortest-path nil))
;;     (labels ((nodes (node)
;;                (cadr (assoc node pad)))
;;              (find-paths (current-node end-node path visited)
;;                (if (eql current-node end-node)
;;                    (push (reverse (cons 'a path)) shortest-path)
;;                    (loop for edge in (nodes current-node)
;;                          for next-node = (car edge)
;;                          do (unless (member next-node visited)
;;                               (find-paths next-node end-node
;;                                           (cons (cdr edge) path)
;;                                           (cons next-node visited)))))))
;;       (find-paths start end nil `(,start)))
;;     (car (stable-sort shortest-path #'< :key #'length))))

(defmemo:defmemo sequence-length (target-sequence depth)
  (if (zerop depth)
      (length target-sequence)
      (iter
        (for next in target-sequence)
        (for current previous next initially 'a)
        (sum (move-count current next depth)))))

(defun move-count (current next depth)
  (if (eq current next)
      1
      (let ((new-sequence (fset:lookup *shortest-path* (list current next))))
        (sequence-length new-sequence (1- depth)))))

(defun code-to-sequence (code)
  (let ((digit0 (digit-char-p (char code 0)))
        (digit1 (digit-char-p (char code 1)))
        (digit2 (digit-char-p (char code 2))))
    (append (fset:lookup *shortest-path* `(a ,digit0))
            (fset:lookup *shortest-path* `(,digit0 ,digit1))
            (fset:lookup *shortest-path* `(,digit1 ,digit2))
            (fset:lookup *shortest-path* `(,digit2 a)))))

(defun calculate-score (code robots)
  (* (parse-integer code :junk-allowed t)
     (sequence-length (code-to-sequence code) robots)))

(defun get-answer-1 (&optional (codes *codes*))
  (gmap:gmap
   (:result :sum)
   (alexandria:rcurry #'calculate-score 2)
   (:arg list codes)))

;; Part 2

(defun get-answer-2 (&optional (codes *codes*))
  (gmap:gmap
   (:result :sum)
   (alexandria:rcurry #'calculate-score 25)
   (:arg list codes)))

;; (defun shortest-paths (start end pad)
;;   (let ((shortest-paths nil)
;;         (shortest-length nil))
;;     (labels ((nodes (node)
;;                (cadr (assoc node pad)))
;;              (find-paths (current-node end-node path visited)
;;                (if (eql current-node end-node)
;;                    (let ((path-length (length path)))
;;                      (cond
;;                        ((null shortest-length)
;;                         (setf shortest-length path-length
;;                               shortest-paths `(,(reverse (cons 'a path)))))
;;                        ((= path-length shortest-length)
;;                         (push (reverse (cons 'a path)) shortest-paths))
;;                        ((< path-length shortest-length)
;;                         (setf shortest-length path-length
;;                               shortest-paths `(,(reverse (cons 'a path)))))))
;;                    (loop for edge in (nodes current-node)
;;                          for next-node = (car edge)
;;                          do (unless (member next-node visited)
;;                               (find-paths next-node end-node
;;                                           (cons (cdr edge) path)
;;                                           (cons next-node visited)))))))
;;       (find-paths start end nil `(,start)))
;;     shortest-paths))
